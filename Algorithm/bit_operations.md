# TIL: 진수 변환과 비트 연산

## 🎯 학습 내용

### 1. 진수 변환

#### 10진수 → 2진수 변환
- **방법**: 2로 나누면서 나머지를 거꾸로 읽기
- **예시**: 13(10) → 1101(2)
  ```
  13 ÷ 2 = 6 ... 1
  6 ÷ 2 = 3 ... 0
  3 ÷ 2 = 1 ... 1
  1 ÷ 2 = 0 ... 1
  → 1101(2)
  ```

#### 10진수 → 16진수 변환
- **방법**: 16으로 나누면서 나머지를 거꾸로 읽기
- **16진수 표기**: 0-9, A(10), B(11), C(12), D(13), E(14), F(15)
- **예시**: 255(10) → FF(16)
  ```
  255 ÷ 16 = 15 ... 15(F)
  15 ÷ 16 = 0 ... 15(F)
  → FF(16)
  ```

#### 2진수 → 16진수 변환
- **방법**: 2진수를 4자리씩 묶어서 각각을 16진수로 변환
- **예시**: 11010111(2) → D7(16)
  ```
  1101 0111
   ↓    ↓
   D    7
  ```

### 2. 비트 연산자

#### 기본 비트 연산자
- **AND (&)**: 둘 다 1일 때만 1
  ```
  1101 & 1011 = 1001
  ```

- **OR (|)**: 하나라도 1이면 1
  ```
  1101 | 1011 = 1111
  ```

- **XOR (^)**: 다를 때만 1
  ```
  1101 ^ 1011 = 0110
  ```

- **NOT (~)**: 비트 반전
  ```
  ~1101 = 0010 (4비트 기준)
  ```

#### 시프트 연산자
- **왼쪽 시프트 (<<)**: 비트를 왼쪽으로 이동 (2배씩 증가)
  ```
  5 << 1 = 10  (101 → 1010)
  5 << 2 = 20  (101 → 10100)
  ```

- **오른쪽 시프트 (>>)**: 비트를 오른쪽으로 이동 (2로 나누기)
  ```
  20 >> 1 = 10  (10100 → 1010)
  20 >> 2 = 5   (10100 → 101)
  ```

### 3. 비트 연산을 활용한 부분집합 만들기

#### 핵심 아이디어
- n개 원소의 부분집합 개수: 2^n개
- 각 부분집합을 0부터 2^n-1까지의 이진수로 표현
- i번째 비트가 1이면 i번째 원소 포함, 0이면 제외

#### 구현 예시 (Python)
```python
def generate_subsets(arr):
    n = len(arr)
    subsets = []
    
    # 0부터 2^n-1까지 모든 경우
    for i in range(1 << n):  # 1 << n은 2^n과 같음
        subset = []
        
        # 각 비트 확인
        for j in range(n):
            # j번째 비트가 1인지 확인
            if i & (1 << j):
                subset.append(arr[j])
        
        subsets.append(subset)
    
    return subsets

# 예시 사용
arr = ['A', 'B', 'C']
print(generate_subsets(arr))
# 결과: [[], ['A'], ['B'], ['A', 'B'], ['C'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']]
```

#### 동작 원리
```
arr = ['A', 'B', 'C']일 때

i=0 (000): {} (공집합)
i=1 (001): {A}
i=2 (010): {B}
i=3 (011): {A, B}
i=4 (100): {C}
i=5 (101): {A, C}
i=6 (110): {B, C}
i=7 (111): {A, B, C}
```

## 💡 핵심 포인트

1. **비트 연산의 효율성**: 부분집합 생성이 매우 빠르고 메모리 효율적
2. **비트마스크**: `1 << j`로 j번째 비트만 1인 수 생성
3. **비트 체크**: `i & (1 << j)`로 i의 j번째 비트가 1인지 확인
4. **응용 분야**: 조합론 문제, 동적 프로그래밍, 집합 연산 등

## 🔗 관련 개념
- 조합(Combination)
- 백트래킹(Backtracking)  
- 동적 프로그래밍(Dynamic Programming)
- 비트마스킹(Bitmask DP)