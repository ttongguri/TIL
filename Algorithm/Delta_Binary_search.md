# μ•κ³ λ¦¬μ¦ κΈ°μ΄ κ°λ… μ •λ¦¬

## π“ ν•™μµ λ‚΄μ©
- λΈνƒ€(Delta) λ°°μ—΄μ„ μ΄μ©ν• λ°©ν–¥ μ§€μ •
- μ΄μ§„ νƒμƒ‰ (Binary Search)
- μ„ νƒ μ •λ ¬ (Selection Sort)

---

## 1. λΈνƒ€(Delta) λ°°μ—΄ 

### κ°λ…
λΈνƒ€ λ°°μ—΄μ€ 2μ°¨μ› λ°°μ—΄μ—μ„ νΉμ • μ„μΉλ΅λ¶€ν„° μƒν•μΆμ° λλ” λ€κ°μ„  λ°©ν–¥μΌλ΅ μ΄λ™ν•  λ• μ‚¬μ©ν•λ” λ°©ν–¥ λ²΅ν„°μ…λ‹λ‹¤.

### μƒν•μΆμ° λ°©ν–¥ μ§€μ •
```python
# μƒ, ν•, μΆ, μ°
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# λλ” μ‹κ³„λ°©ν–¥μΌλ΅
dx = [-1, 0, 1, 0]  # μƒ, μ°, ν•, μΆ
dy = [0, 1, 0, -1]
```

### λ€κ°μ„  ν¬ν•¨ 8λ°©ν–¥
```python
# μƒ, μƒμ°, μ°, ν•μ°, ν•, ν•μΆ, μΆ, μƒμΆ
dx = [-1, -1, 0, 1, 1, 1, 0, -1]
dy = [0, 1, 1, 1, 0, -1, -1, -1]
```

### μ‚¬μ© μμ‹
```python
def explore_directions(board, x, y):
    dx = [-1, 1, 0, 0]  # μƒν•μΆμ°
    dy = [0, 0, -1, 1]
    
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        
        # λ²”μ„ μ²΄ν¬
        if 0 <= nx < len(board) and 0 <= ny < len(board[0]):
            # ν•΄λ‹Ή λ°©ν–¥μΌλ΅ μ΄λ™ κ°€λ¥ν• κ²½μ° μ²λ¦¬
            print(f"μ΄λ™ κ°€λ¥: ({nx}, {ny})")
```

### π’΅ ν•µμ‹¬ ν¬μΈνΈ
- `dx[i], dy[i]`λ” ν•­μƒ μμΌλ΅ μ‚¬μ©
- λ°°μ—΄ λ²”μ„λ¥Ό λ²—μ–΄λ‚μ§€ μ•λ„λ΅ κ²½κ³„ κ²€μ‚¬ ν•„μ
- λ°©ν–¥μ μμ„λ¥Ό μΌκ΄€μ„± μκ² μ •μ

---

## 2. μ΄μ§„ νƒμƒ‰ (Binary Search) π”

### κ°λ…
**μ •λ ¬λ λ°°μ—΄**μ—μ„ νΉμ • κ°’μ„ μ°Ύλ” ν¨μ¨μ μΈ μ•κ³ λ¦¬μ¦μΌλ΅, κ²€μƒ‰ λ²”μ„λ¥Ό μ λ°μ”© μ¤„μ—¬λ‚κ°€λ” λ°©μ‹μ…λ‹λ‹¤.

### μ‹κ°„ λ³µμ΅λ„
- **O(log n)** - λ§¤λ² κ²€μƒ‰ λ²”μ„κ°€ μ λ°μΌλ΅ μ¤„μ–΄λ“¦

### κµ¬ν„ λ°©λ²•

#### λ°λ³µλ¬Έ λ²„μ „
```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # μ°Ύμ§€ λ»ν• κ²½μ°
```

#### μ¬κ·€ λ²„μ „
```python
def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)
```

### π’΅ ν•µμ‹¬ ν¬μΈνΈ
- **μ •λ ¬λ λ°°μ—΄**μ—μ„λ§ μ‚¬μ© κ°€λ¥
- `left <= right` μ΅°κ±΄ μ£Όμ
- `mid = (left + right) // 2`λ΅ μ¤‘κ°„κ°’ κ³„μ‚°

---

## 3. μ„ νƒ μ •λ ¬ (Selection Sort) π“

### κ°λ…
λ°°μ—΄μ—μ„ **μµμ†κ°’μ„ μ°Ύμ•„μ„ λ§¨ μ•μΌλ΅ μ΄λ™**μ‹ν‚¤λ” κ³Όμ •μ„ λ°λ³µν•λ” μ •λ ¬ μ•κ³ λ¦¬μ¦μ…λ‹λ‹¤.

### μ‹κ°„ λ³µμ΅λ„
- **O(nΒ²)** - λ¨λ“  κ²½μ°μ— λ™μΌ (μµμ„ , ν‰κ· , μµμ•…)
- κ³µκ°„ λ³µμ΅λ„: **O(1)** - μ μλ¦¬ μ •λ ¬

### λ™μ‘ κ³Όμ •
1. λ°°μ—΄μ—μ„ μµμ†κ°’μ„ μ°Ύλ”λ‹¤
2. μµμ†κ°’μ„ λ§¨ μ• μ”μ†μ™€ κµν™ν•λ‹¤
3. μ •λ ¬λ λ¶€λ¶„μ„ μ μ™Έν•κ³  μ„ κ³Όμ •μ„ λ°λ³µν•λ‹¤

### κµ¬ν„
```python
def selection_sort(arr):
    n = len(arr)
    
    for i in range(n - 1):
        # μµμ†κ°’μ μΈλ±μ¤λ¥Ό μ°ΎκΈ°
        min_idx = i
        
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        
        # μµμ†κ°’μ„ ν„μ¬ μ„μΉλ΅ μ΄λ™
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    
    return arr
```

### μμ‹ μ‹¤ν–‰ κ³Όμ •
```
μ΄κΈ°: [64, 25, 12, 22, 11]

1νμ „: [11, 25, 12, 22, 64]  # 11μ΄ λ§¨ μ•μΌλ΅
2νμ „: [11, 12, 25, 22, 64]  # 12κ°€ λ‘ λ²μ§Έλ΅
3νμ „: [11, 12, 22, 25, 64]  # 22κ°€ μ„Έ λ²μ§Έλ΅
4νμ „: [11, 12, 22, 25, 64]  # 25κ°€ λ„¤ λ²μ§Έλ΅ (μ™„λ£)
```

### π’΅ ν•µμ‹¬ ν¬μΈνΈ
- λ§¤λ² λ‚¨μ€ λ°°μ—΄μ—μ„ μµμ†κ°’μ„ μ°Ύμ•„ μ•μΌλ΅ μ΄λ™
- μ•μ • μ •λ ¬μ΄ μ•„λ‹ (λ™μΌν• κ°’μ μμ„κ°€ λ°”λ€” μ μμ)
- λΉ„κµ νμκ°€ ν•­μƒ λ™μΌν•μ—¬ μ„±λ¥μ΄ μΌμ •ν•¨

---

## π“ μ¤λμ μ •λ¦¬

1. **λΈνƒ€ λ°°μ—΄**μ€ 2D λ°°μ—΄μ—μ„ λ°©ν–¥ μ΄λ™μ„ κΉ”λ”ν•κ² μ²λ¦¬ν•  μ μλ” ν•µμ‹¬ κΈ°λ²•
2. **μ΄μ§„ νƒμƒ‰**μ€ μ •λ ¬λ λ°μ΄ν„°μ—μ„ O(log n)μ λΉ λ¥Έ κ²€μƒ‰ μ„±λ¥ μ κ³µ
3. **μ„ νƒ μ •λ ¬**μ€ μ§κ΄€μ μ΄μ§€λ§ O(nΒ²)λ΅ ν° λ°μ΄ν„°μ—λ” λΉ„ν¨μ¨μ 

### λ‹¤μμ— ν•™μµν•  κ²ƒ
- BFS/DFSμ—μ„ λΈνƒ€ λ°°μ—΄ ν™μ©
- μ΄μ§„ νƒμƒ‰μ λ³€ν• λ¬Έμ λ“¤ (lower_bound, upper_bound)
- λ” ν¨μ¨μ μΈ μ •λ ¬ μ•κ³ λ¦¬μ¦λ“¤ (ν€µ μ •λ ¬, λ³‘ν•© μ •λ ¬)