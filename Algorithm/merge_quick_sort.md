# 병합정렬과 퀵정렬

## 병합정렬 (Merge Sort)

### 개념
병합정렬은 분할정복(Divide and Conquer) 알고리즘의 대표적인 예시이다. 배열을 절반으로 나누어 각각을 정렬한 후, 정렬된 두 배열을 합치는 방식으로 동작한다.

### 동작 원리
1. **분할(Divide)**: 배열을 절반으로 나눈다
2. **정복(Conquer)**: 각 부분 배열을 재귀적으로 정렬한다
3. **결합(Combine)**: 정렬된 두 배열을 하나의 정렬된 배열로 합친다

### 시간복잡도
- **최선, 평균, 최악**: O(n log n)
- **공간복잡도**: O(n)

### 특징
- **안정 정렬**: 동일한 값의 상대적 순서가 유지된다
- **일관성**: 어떤 경우에도 O(n log n)의 성능을 보장한다
- **메모리 사용**: 추가 메모리 공간이 필요하다

### 구현 예시 (Python)
```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    # 분할
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # 병합
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 남은 요소들 추가
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result
```

---

## 퀵정렬 (Quick Sort)

### 개념
퀵정렬은 분할정복 알고리즘으로, 피벗(pivot)을 선택하여 피벗보다 작은 값들과 큰 값들로 배열을 나누어 정렬하는 방식이다.

### 동작 원리
1. **피벗 선택**: 배열에서 하나의 원소를 피벗으로 선택한다
2. **분할**: 피벗을 기준으로 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 배치한다
3. **정복**: 분할된 부분 배열들을 재귀적으로 정렬한다

### 시간복잡도
- **최선, 평균**: O(n log n)
- **최악**: O(n²) - 이미 정렬된 배열에서 첫 번째나 마지막 원소를 피벗으로 선택할 때
- **공간복잡도**: O(log n) - 재귀 호출 스택

### 특징
- **불안정 정렬**: 동일한 값의 상대적 순서가 바뀔 수 있다
- **제자리 정렬**: 추가 메모리 공간이 거의 필요하지 않다
- **피벗 선택이 중요**: 성능이 피벗 선택에 크게 좌우된다

### 구현 예시 (Python)
```python
def quick_sort(arr, low=0, high=None):
    if high is None:
        high = len(arr) - 1
    
    if low < high:
        # 분할
        pivot_index = partition(arr, low, high)
        
        # 재귀적 정렬
        quick_sort(arr, low, pivot_index - 1)
        quick_sort(arr, pivot_index + 1, high)

def partition(arr, low, high):
    pivot = arr[high]  # 마지막 원소를 피벗으로 선택
    i = low - 1
    
    for j in range(low, high):
        if arr[j] <= pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1
```

---

## 병합정렬 vs 퀵정렬 비교

| 특성 | 병합정렬 | 퀵정렬 |
|------|----------|--------|
| 시간복잡도 (평균) | O(n log n) | O(n log n) |
| 시간복잡도 (최악) | O(n log n) | O(n²) |
| 공간복잡도 | O(n) | O(log n) |
| 안정성 | 안정 정렬 | 불안정 정렬 |
| 제자리 정렬 | X | O |
| 성능 일관성 | 일관됨 | 피벗에 따라 변동 |

---

## 언제 사용할까?

### 병합정렬을 선택하는 경우
- 안정 정렬이 필요한 경우
- 일관된 성능이 중요한 경우
- 메모리 사용량보다 성능의 예측 가능성이 중요한 경우

### 퀵정렬을 선택하는 경우
- 메모리 사용량을 최소화하고 싶은 경우
- 평균적으로 빠른 성능이 필요한 경우
- 실제 데이터에서 최악의 경우가 드문 경우

---

---

## 빅오 표기법의 한계

### 왜 퀵정렬이 평균적으로 더 빠른가?
병합정렬과 퀵정렬 모두 O(n log n)이지만, 실제 성능에서는 퀵정렬이 보통 1.5~2배 빠르다. 이는 빅오 표기법의 한계 때문이다.

### 빅오 표기법의 한계들

#### 1. 상수 계수 무시
- O(10n)과 O(1000n) 둘 다 O(n)으로 표현
- 실제로는 100배 차이가 날 수 있음

#### 2. 낮은 차수 항 무시
- O(n² + 1000n)을 O(n²)로 표현
- 작은 입력에서는 1000n이 더 클 수도 있음

#### 3. 점근적 행동만 고려
- 입력 크기가 **충분히 클 때**의 행동만 분석
- 실제 프로그램에서 다루는 크기에서는 다를 수 있음

#### 4. 실제 연산의 차이 반영 못함
```
퀵정렬: 비교 + 교환 (캐시 지역성 좋음)
병합정렬: 비교 + 복사 + 배열 생성 (메모리 접근 복잡)
```

### 실제 예시
```
알고리즘 A: 실제 시간 = 100n log n
알고리즘 B: 실제 시간 = n log n

n = 1000일 때:
A: 약 996,000
B: 약 9,960  ← B가 훨씬 빠름

둘 다 O(n log n)이지만 상수 계수로 인한 실제 차이는 큼!
```

### 결론
알고리즘 선택 시 고려사항:
- **빅오 표기법**: 대략적인 효율성 가이드라인
- **실제 구현과 측정**: 정확한 성능 확인
- **입력 크기와 특성**: 실제 사용 환경 고려

---

## 추가 팁
- 퀵정렬의 최악 케이스를 피하기 위해 **랜덤 피벗** 선택이나 **3-way partitioning** 사용
- 작은 배열에서는 **삽입 정렬**이 더 효율적일 수 있음
- Python의 내장 `sort()`는 **Timsort**라는 병합정렬과 삽입정렬의 하이브리드 알고리즘 사용